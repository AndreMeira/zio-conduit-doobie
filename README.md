## Scala 3 + ZIO + Doobie + Opentelemetry code base containing reald world examples.

A simplified version of an article platform, like [medium.com](medium.com).
This is the backend side of the platform, exposing a REST API to manage users and articles.

This includes a pure inmemory implementation and a Doobie implementation using a Postgres database.
It also includes a basic trace visualisation for the inmemory implementation and OpenTelemetry tracing and metrics for a deployable version.

There is a script for dockerising the app, and another script for running locally the containerised app.


### Application stack
- Scala 3 (Scala is a general-purpose programming language that supports both object-oriented and functional programming paradigms.)
- ZIO (a library for asynchronous and concurrent programming in Scala, providing a purely functional approach to handling side effects and managing state.)
- Doobie (a pure functional JDBC layer for Scala, providing a type-safe and composable way to interact with relational databases.)
- ZIO HTTP (a high-performance, purely functional HTTP library for building web applications and services in Scala using the ZIO effect system.)
- OpenTelemetry (a set of APIs, libraries, agents, and instrumentation to provide observability for applications, including tracing, metrics, and logging.)
- Postgres (database)
- Json Web Tokens (JWT)
- Flyway for database migrations 

### Architecture 
The application is structured in layers, following the principles of Clean Architecture and Hexagonal Architecture.
- **Domain Layer**: Contains the core business logic and domain models.
    - logic (contains all the interfaces of the different services)
    - model (contains all the domain models)
    - service (contains the implementations of the business logic)
- **Infrastructure Layer**: Contains implementations for interacting with external systems, such as databases and web servers.
- **Application Layer**: Contains the orchestration and wiring between the domain and infrastructure layers.

### Usage

You can launch the application in different modes:
- In-memory mode: `sbt "runMain Main http inmemory"` . This mode uses an in-memory implementation for the repositories and a simple html-based trace visualisation.
You can access the last trace generated by clicking on the file `./html/last-trace.html`. This mode
is useful for experimenting and testing the application without needing a database (e.g. for development of a frontend or demo purposes).
- Local mode: `sbt "runMain Main http local"`. This mode uses a Postgres database.
You need to have Docker installed and running. You also need to run `docker-compose up` before launching the application.
This mode will launch the flyway migration in the same process as the application. It is the mode you might want to use for local development and proper trace visualisation.
You can visualise the traces using Jaeger at `http://localhost:3000/`. 
- Migration: `sbt "runMain Main database migrate"`. This will run the database migrations using Flyway.
It is useful in a real world use case when you want to run the migrations as a separate step in your deployment pipeline.
- Live mode: `sbt "runMain Main http live"`. This mode is intended for deployment in a production environment.
It should be run after the database migrations have been applied using the `database migrate` command.

You can also run all of those mode inside a Docker container using the provided scripts:
- `./bin/dockerize.sh`: This script will create a Docker image containing the application.
- `./bin/run-in-docker.sh <mode>`. This script will run the application in a Docker container in the specified mode.
the available modes are "http inmemory", "http local", "database migrate" and "http live".
If you are not running the in-memory mode, you need to launch `docker-compose up` before running the script.

### Testing 

You can run the tests using `sbt test`. The tests are written using ZIO Test.
The tests are restricted to postgres implementation at the moment.